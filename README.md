# gensynet


A JSONic way to interactively **gen**erate a **sy**nthetic **net**work spec and its network host descriptions. These host
JSON objects are then written to a timestamped file.

## usage

	python3 gensynet.py -h
	usage: gensynet.py [-h] [-v] [--version]

	optional arguments:
	  -h, --help     show this help message and exit
	  -v, --verbose  Provide program feedback
	  --version      Prints version


##  useful functions

The Python library can be imported as `import gensynet` with the following (hopefully helpful) internal functions:

### generate_ip(prefix)

Takes in a partial IP string and returns a random IP string.

        >>> gensynet.generate_ip('10.0')
        '10.0.128.53'


### generate_fqdn(domain=None, subdomains=0)

Takes in a domain (or randomly generates a gibberish one if none is provided), and builds a FQDN with the specified
number of subdomains.

	>>> gensynet.generate_fqdn(subdomains=1)
	'awf.9c24by18nc.local'
	>>> gensynet.generate_fqdn()
	'nm3li.local'
	>>> gensynet.generate_fqdn(domain='a.internal', subdomains=2)
	'dltyf.7jwmi.a.internal'


### calculate_subnets(total, breakdown)

Given a total number of hosts and the desired breakdown in 2-tuples (with the first number being the percentage
of the total number of hosts, and the second number being the percentage of occupied Class C address space), calculate
how many subnets are needed to put every host in a subnet. This function returns -1 if the percentages or breakdowns
don't make sense. Obviously, there will be some networks with sparser-than-specified occupancies, in the event that there
still remains a surplus of hosts after dividing them up into the designated Class C space.


### build_configs(total, net_div, dev_div, domain)

Takes the total number of hosts, the breakdown of the network as specified in 2-tuples, the breakdown of network devices
(provided as a dictionary of `'device': integer(count)`), and a domain (if any), and builds JSON profiles of each subnet
space that makes up the rest of the network.

	>>> j = gensynet.build_configs(total=100, net_div=[(50, 50), (15, 10), (35,15)], dev_div={'Developer workstation':
	35, 'Business workstation': 50, 'Smartphone': 5, 'Printer': 1, 'File server': 5, 'SSH server': 4}, domain=None)

	Initialized subnet 2 with 50 hosts starting at 10.0.2.1
	Initialized subnet 1 with 15 hosts starting at 10.0.1.1
	Initialized subnet 0 with 35 hosts starting at 10.0.0.1
	>>> for i in j:
	...     print(json.dumps(i.get(), indent=2))
	...
	{
	  "start_ip": "10.0.2.1",
	  "netmask": "10.0.2.0/24",
	  "roles": {
	    "Business workstation": 17,
	    "SSH server": 2,
	    "File server": 3,
	    "Printer": 0,
	    "Developer workstation": 23,
	    "Smartphone": 5
	  },
	  "hosts": 50
	}
	{
	  "start_ip": "10.0.1.1",
	  "netmask": "10.0.1.0/24",
	  "roles": {
	    "Business workstation": 15,
	    "SSH server": 0,
	    "File server": 0,
	    "Printer": 0,
	    "Developer workstation": 0,
	    "Smartphone": 0
	  },
	  "hosts": 15
	}
	{
	  "start_ip": "10.0.0.1",
	  "netmask": "10.0.0.0/24",
	  "roles": {
	    "Business workstation": 18,
	    "SSH server": 2,
	    "File server": 2,
	    "Printer": 1,
	    "Developer workstation": 12,
	    "Smartphone": 0
	  },
	  "hosts": 35
	}


### build_network(subnets, fname, randomspace, prettyprint)

This is the real meat and potatoes part of the script, which takes the subnet specifications as generated by build_configs()
and outputs the JSON descriptions of each host into the file `fname`. There are two additional configurations that can be
toggled: if `randomspace` is set to `True`, the IP addresses are randomized across their respective subnets, and are
otherwise generated sequentially; if `prettyprint` is set to `True`, the JSON is broken up into a human-readable fashion,
and are otherwise written to file in a single line.

## bugs and other questions

Please report bugs and issues by opening a ticket on the project's GitHub page.
